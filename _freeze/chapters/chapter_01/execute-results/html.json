{
  "hash": "6a2caf93b49d449e58ff9840940bea07",
  "result": {
    "engine": "knitr",
    "markdown": "---\nexecute: \n  echo: true\n  eval: false\n  warning: false\n---\n\n\n# Obtaining species trees for Ensembl instances\n\nHere, we will describe the code to obtain a species tree for each Ensembl\ninstance using BUSCO genes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(tidyverse)\nlibrary(biomaRt)\nlibrary(Herper)\nlibrary(taxize)\nlibrary(Biostrings)\nlibrary(cogeqc)\n\nset.seed(123) # for reproducibility\noptions(timeout = 1e6) # to allow download of big files\n\nsource(here(\"code\", \"utils.R\"))\nsource(here(\"code\", \"utils_busco_phylogeny.R\"))\n```\n:::\n\n\n## Summary stats\n\nTo start with, let's get the number of species for each instance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get number of species in Ensembl Genomes\ninstances <- c(\"fungi_mart\", \"plants_mart\", \"metazoa_mart\", \"protists_mart\")\nnspecies_ensemblgenomes <- unlist(lapply(instances, function(x) {\n    return(nrow(listDatasets(useEnsemblGenomes(biomart = x))))\n}))\n\n# Get number of species in Ensembl\nnspecies_ensembl <- nrow(listDatasets(useEnsembl(biomart = \"genes\")))\n\n# Combine summary stats onto a data frame\nnspecies_all <- data.frame(\n    instance = c(gsub(\"_mart\", \"\", instances), \"ensembl\"),\n    n_genes = c(nspecies_ensemblgenomes, nspecies_ensembl)\n)\n\nnspecies_all\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  instance n_genes\n1    fungi      70\n2   plants     151\n3  metazoa     280\n4 protists      33\n5  ensembl     214\n```\n\n\n:::\n:::\n\n\n## Getting species metadata\n\nNow, let's get species metadata for each Ensembl instance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Metadata column names\ncol_names <- c(\n    \"name\", \"species\", \"division\", \"taxonomy_id\", \"assembly\", \n    \"assembly_accession\", \"genebuild\", \"variation\", \"microarray\", \"pan_compara\",\n    \"peptide_compara\", \"genome_alignments\", \"other_alignments\", \"core_db\",\n    \"species_id\"\n)\n\nto_remove <- c(\n    \"variation\", \"microarray\", \"pan_compara\", \"peptide_compara\", \n    \"genome_alignments\", \"other_alignments\", \"core_db\", \"species_id\"\n)\n\n# Ensembl Fungi\nmetadata_fungi <- read_tsv(\n    \"http://ftp.ebi.ac.uk/ensemblgenomes/pub/release-57/fungi/species_EnsemblFungi.txt\",\n    col_names = col_names, skip = 1, col_select = 1:15, show_col_types = FALSE\n) |>\n    dplyr::filter(!startsWith(core_db, \"fungi_\")) |>\n    dplyr::select(!any_of(to_remove)) |>\n    as.data.frame()\n\nmetadata_fungi <- cbind(\n    metadata_fungi,\n    classification(metadata_fungi$taxonomy_id, db = \"ncbi\") |>\n        format_classification()\n)\n\n# Ensembl Plants\nmetadata_plants <- read_tsv(\n    \"http://ftp.ebi.ac.uk/ensemblgenomes/pub/release-57/plants/species_EnsemblPlants.txt\",\n    col_names = col_names, skip = 1, col_select = 1:15, show_col_types = FALSE\n) |>\n    dplyr::filter(species != \"triticum_aestivum_kariega\") |>\n    dplyr::select(!any_of(to_remove)) |>\n    as.data.frame()\n\nmetadata_plants <- cbind(\n    metadata_plants,\n    classification(metadata_plants$taxonomy_id, db = \"ncbi\") |>\n        format_classification()\n)\n\n# Ensembl Metazoa\nmetadata_metazoa <- read_tsv(\n    \"http://ftp.ebi.ac.uk/ensemblgenomes/pub/release-57/metazoa/species_EnsemblMetazoa.txt\",\n    col_names = col_names, skip = 1, col_select = 1:15, show_col_types = FALSE\n) |>\n    dplyr::filter(!startsWith(core_db, \"metazoa_\")) |>\n    dplyr::select(!any_of(to_remove)) |>\n    as.data.frame()\n\nmetadata_metazoa <- cbind(\n    metadata_metazoa,\n    classification(metadata_metazoa$taxonomy_id, db = \"ncbi\") |>\n        format_classification()\n)\n\n# Ensembl Protists\nmetadata_protists <- read_tsv(\n    \"http://ftp.ebi.ac.uk/ensemblgenomes/pub/release-57/protists/species_EnsemblProtists.txt\",\n    col_names = col_names, skip = 1, col_select = 1:15, show_col_types = FALSE\n) |>\n    dplyr::filter(!startsWith(core_db, \"protists_\")) |>\n    dplyr::select(!any_of(to_remove)) |>\n    as.data.frame()\n\nmetadata_protists <- cbind(\n    metadata_protists,\n    classification(metadata_protists$taxonomy_id, db = \"ncbi\") |>\n        format_classification()\n)\n\n# Ensembl\nmetadata_ensembl <- read_tsv(\n    \"https://ftp.ensembl.org/pub/release-110/species_EnsemblVertebrates.txt\",\n    col_names = col_names, skip = 1, col_select = 1:15, show_col_types = FALSE\n) |>\n    dplyr::select(!any_of(to_remove)) |>\n    as.data.frame()\n\nmetadata_ensembl <- cbind(\n    metadata_ensembl,\n    classification(metadata_ensembl$taxonomy_id, db = \"ncbi\") |>\n        format_classification()\n)\n\n# Combining all metadata data frames into a list and saving it\nmetadata_all <- list(\n    fungi = metadata_fungi,\n    plants = metadata_plants,\n    metazoa = metadata_metazoa,\n    protists = metadata_protists,\n    ensembl = metadata_ensembl\n)\n\nsave(\n    metadata_all, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"metadata_all.rda\")\n)\n```\n:::\n\n\n\n## BUSCO-guided phylogeny inference\n\nHere, for each Ensembl instance, we infer a species tree using the following\nworkflow:\n\n1. Run BUSCO in protein mode with __cogeqc__,\nusing translated sequences for primary transcripts as input;\n2. Get the sequences of the identified complete BUSCOs that are shared\nacross all species;\n3. Perform a multiple sequence alignment for each BUSCO gene family.\n4. Trim the alignments to remove columns with >50% of gaps. \n5. Infer a phylogeny with IQ-TREE2.\n\nTo start with, we will use the Bioconductor \npackage __Herper__ to create a Conda environment\ncontaining BUSCO and all its dependencies. Then, we will use this environment\nto run BUSCO from the R session.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create Conda environment with BUSCO\nmy_miniconda <- \"~/\"\n\nconda <- install_CondaTools(\n    tools = \"busco==5.5.0\",\n    env = \"busco_env\",\n    pathToMiniConda = my_miniconda\n)\n```\n:::\n\n\n### Obtaining BUSCO sequences\n\nTo obtain sequences for BUSCO genes, we will run BUSCO in protein mode\nusing the R/Bioconductor package __cogeqc__. Then, we will\nread the sequences for complete, single-copy BUSCOs, and keep only\nBUSCO genes that are shared by a certain % of the species. Ideally,\nthis cut-off should be 100% of conservation (i.e., the BUSCO gene is found\nin all species), but it can be relaxed for some clades.\n\n\n::: {.cell}\n\n:::\n\n\n#### Ensembl Fungi\n\nHere, we will obtain BUSCO genes for Ensembl Fungi species using the following\nparameters:\n\n1. Lineage: **eukaryota_odb10**\n2. Conservation: 100%\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download whole-genome protein sequences to a directory sequences\nbusco_fungi <- file.path(\"~/Downloads/busco_fungi\")\nseq_fungi <- file.path(busco_fungi, \"seqs\")\nif(!dir.exists(seq_fungi)) { dir.create(seq_fungi, recursive = TRUE) }\n\ndownload_filtered_proteomes(metadata_all$fungi, \"fungi\", seq_fungi)\n\n# Run BUSCO in `protein` mode\nwith_CondaEnv(\n    \"busco_env\",\n    cogeqc::run_busco(\n        sequence = seq_fungi, \n        outlabel = \"ensembl_fungi\",\n        mode = \"protein\",\n        lineage = \"eukaryota_odb10\",\n        outpath = busco_fungi,\n        threads = 3,\n        download_path = busco_fungi\n        \n    ),\n    pathToMiniConda = my_miniconda\n)\n\noutdir <- file.path(busco_fungi, \"ensembl_fungi\")\nfungi_busco_seqs <- read_busco_sequences(outdir, verbose = TRUE)\n```\n:::\n\n\nSaving BUSCO sequences:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save list of AAStringSet objects with conserved BUSCO sequences\nsave(\n    fungi_busco_seqs, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"busco_seqs\", \"fungi_busco_seqs.rda\")\n)\n```\n:::\n\n\n#### Ensembl Plants\n\nHere, we will use the lineage data set **eukaryota_odb10**. We could use\n**viridiplantae_odb10**, but there are 3 Rhodophyta species \n(*Chondrus crispus*, *Galdieria sulphuraria*, and *Cyanidioschyzon merolae*).\nBecause none of the BUSCO genes were shared by all species, we selected\ngenes shared by >60% of the species, and then manually selected BUSCO genes\nin a way that all species are included. This was required because some taxa\n(in particular *Triticum* species) had very few BUSCO genes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download whole-genome protein sequences to a directory sequences\nbusco_plants <- file.path(\"~/Downloads/busco_plants\")\nseq_plants <- file.path(busco_plants, \"seqs\")\nif(!dir.exists(seq_plants)) { dir.create(seq_plants, recursive = TRUE) }\n\ndownload_filtered_proteomes(metadata_all$plants, \"plants\", seq_plants)\n\n# Run BUSCO in `protein` mode\nwith_CondaEnv(\n    \"busco_env\",\n    cogeqc::run_busco(\n        sequence = seq_plants, \n        outlabel = \"ensemblplants\",\n        mode = \"protein\",\n        lineage = \"eukaryota_odb10\",\n        outpath = busco_plants,\n        threads = 4,\n        download_path = busco_plants\n        \n    ),\n    pathToMiniConda = my_miniconda\n)\n\n# Read sequences of BUSCOs preserved in >=60% of the species\noutdir <- file.path(busco_plants, \"ensemblplants\")\nplants_busco_seqs <- read_busco_sequences(outdir, conservation_freq = 0.6)\n\n# Select 10 BUSCO genes so that all species are represented\nplants_busco_pav <- get_busco_pav(plants_busco_seqs)\n\n#' The following code was used to manually select BUSCOs in a way that\n#' all species are represented\n\n#> ht <- ComplexHeatmap::Heatmap(plants_busco_pav)\n#> ht <- ComplexHeatmap::draw(ht)\n#> InteractiveComplexHeatmap::htShiny(ht)\n\n\n# Create a vector of selected BUSCOs\nselected_buscos <- c(\n    \"549762at2759\", \"1003258at2759\", \"1247641at2759\",\n    \"1200489at2759\", \"1398309at2759\", \"1346432at2759\",\n    \"1266231at2759\", \"1094121at2759\", \"1421503at2759\",\n    \"664730at2759\", \"1405073at2759\", \"450058at2759\",\n    \"865202at2759\", \"901894at2759\", \"1450538at2759\",\n    \"1284731at2759\"\n)\n\n# Subset sequences to keep only selected BUSCOs\nplants_busco_seqs <- plants_busco_seqs[selected_buscos]\n```\n:::\n\n\nSaving BUSCO sequences:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save list of AAStringSet objects with conserved BUSCO sequences\nsave(\n    plants_busco_seqs, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"busco_seqs\", \"plants_busco_seqs.rda\")\n)\n```\n:::\n\n\n#### Ensembl Protists\n\nHere, we will obtain BUSCO genes for Ensembl Protists species using \nthe following parameters:\n\n1. Lineage: **eukaryota_odb10**\n2. Conservation: 100%\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download whole-genome protein sequences to a directory sequences\nbusco_protists <- file.path(\"~/Downloads/busco_protists\")\nseq_protists <- file.path(busco_protists, \"seqs\")\nif(!dir.exists(seq_protists)) { dir.create(seq_protists, recursive = TRUE) }\n\ndownload_filtered_proteomes(metadata_all$protists, \"protists\", seq_protists)\n\n# Run BUSCO in `protein` mode\nwith_CondaEnv(\n    \"busco_env\",\n    cogeqc::run_busco(\n        sequence = seq_protists, \n        outlabel = \"ensemblprotists\",\n        mode = \"protein\",\n        lineage = \"eukaryota_odb10\",\n        outpath = busco_protists,\n        threads = 4,\n        download_path = busco_protists\n        \n    ),\n    pathToMiniConda = my_miniconda\n)\n\n# Read sequences of BUSCOs preserved in >=60% of the species\noutdir <- file.path(busco_protists, \"ensemblprotists\")\nprotists_busco_seqs <- read_busco_sequences(outdir, verbose = TRUE)\n```\n:::\n\n\nSaving BUSCO sequences:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save list of AAStringSet objects with conserved BUSCO sequences\nsave(\n    protists_busco_seqs, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"busco_seqs\", \"protists_busco_seqs.rda\")\n)\n```\n:::\n\n\n#### Ensembl Metazoa\n\nFor the Metazoa instance, we used the *metazoa_odb10* lineage data set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download whole-genome protein sequences to a directory sequences\nbusco_metazoa <- file.path(\"~/Downloads/busco_metazoa\")\nseq_metazoa <- file.path(busco_metazoa, \"seqs\")\nif(!dir.exists(seq_metazoa)) { dir.create(seq_metazoa, recursive = TRUE) }\n\ndownload_filtered_proteomes(metadata_all$metazoa, \"metazoa\", seq_metazoa)\n\n# Run BUSCO in `protein` mode\nwith_CondaEnv(\n    \"busco_env\",\n    cogeqc::run_busco(\n        sequence = seq_metazoa, \n        outlabel = \"ensemblmetazoa\",\n        mode = \"protein\",\n        lineage = \"metazoa_odb10\",\n        outpath = busco_metazoa,\n        threads = 4,\n        download_path = busco_metazoa\n        \n    ),\n    pathToMiniConda = my_miniconda\n)\n\n# Read sequences of BUSCOs preserved in >=60% of the species\noutdir <- file.path(busco_metazoa, \"ensemblmetazoa\")\nmetazoa_busco_seqs <- read_busco_sequences(outdir, conservation_freq = 0.9)\n\n# Select 10 BUSCO genes so that all species are represented\nmetazoa_busco_pav <- get_busco_pav(metazoa_busco_seqs)\n\n#' The following code was used to manually select BUSCOs in a way that\n#' all species are represented\n\n#> ht <- ComplexHeatmap::Heatmap(metazoa_busco_pav)\n#> ht <- ComplexHeatmap::draw(ht)\n#> InteractiveComplexHeatmap::htShiny(ht)\n\n\n# Create a vector of selected BUSCOs\nselected_buscos <- c(\n    \"351226at33208\", \"135294at33208\",\n    \"517525at33208\", \"501396at33208\",\n    \"464987at33208\", \"443518at33208\",\n    \"495100at33208\", \"335107at33208\",\n    \"454911at33208\", \"134492at33208\"\n)\n\n# Subset sequences to keep only selected BUSCOs\nmetazoa_busco_seqs <- metazoa_busco_seqs[selected_buscos]\n```\n:::\n\n\nSaving BUSCO sequences:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save list of AAStringSet objects with conserved BUSCO sequences\nsave(\n    metazoa_busco_seqs, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"busco_seqs\", \"metazoa_busco_seqs.rda\")\n)\n```\n:::\n\n\n\n#### Ensembl Vertebrates\n\nHere, because there are 3 non-vertebrate species (*C. elegans*,\n*D. melanogaster*, and *S. cerevisiae*), we will use the lineage data set\n**eukaryota_odb10**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download whole-genome protein sequences to a directory sequences\nbusco_vertebrates <- file.path(\"~/Downloads/busco_vertebrates\")\nseq_vertebrates <- file.path(busco_vertebrates, \"seqs\")\nif(!dir.exists(seq_vertebrates)) { dir.create(seq_vertebrates, recursive = TRUE) }\n\ndownload_filtered_proteomes(metadata_all$ensembl, \"ensembl\", seq_vertebrates)\n\n# Run BUSCO in `protein` mode\nwith_CondaEnv(\n    \"busco_env\",\n    cogeqc::run_busco(\n        sequence = seq_vertebrates, \n        outlabel = \"ensemblvertebrates\",\n        mode = \"protein\",\n        lineage = \"eukaryota_odb10\",\n        outpath = busco_vertebrates,\n        threads = 4,\n        download_path = busco_vertebrates\n        \n    ),\n    pathToMiniConda = my_miniconda\n)\n\n# Read sequences of BUSCOs preserved in >=90% of the species\noutdir <- file.path(busco_vertebrates, \"ensemblvertebrates\")\nvertebrates_busco_seqs <- read_busco_sequences(outdir, conservation_freq = 0.9)\n\n# Select 10 BUSCO genes so that all species are represented\nvertebrates_busco_pav <- get_busco_pav(vertebrates_busco_seqs)\n\n#' The following code was used to manually select BUSCOs in a way that\n#' all species are represented\n\n#> ht <- ComplexHeatmap::Heatmap(vertebrates_busco_pav)\n#> ht <- ComplexHeatmap::draw(ht)\n#> InteractiveComplexHeatmap::htShiny(ht)\n\n\n# Create a vector of selected BUSCOs\nselected_buscos <- c(\n    \"834694at2759\", \"551907at2759\",\n    \"491869at2759\", \"1085752at2759\",\n    \"801857at2759\", \"1398309at2759\",\n    \"176625at2759\", \"1324510at2759\",\n    \"1377237at2759\", \"1085752at2759\"\n)\n\n# Subset sequences to keep only selected BUSCOs\nvertebrates_busco_seqs <- vertebrates_busco_seqs[selected_buscos]\n```\n:::\n\n\nSaving BUSCO sequences:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save list of AAStringSet objects with conserved BUSCO sequences\nsave(\n    vertebrates_busco_seqs, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"busco_seqs\", \"vertebrates_busco_seqs\")\n)\n```\n:::\n\n\n\n### Tree inference from BUSCO genes\n\nNow, we will infer species trees from MSAs for each family, and from\na single concatenated MSA (when possible).\n\n#### Ensembl Fungi\n\nPerforming MSA with MAFFT and trimming the alignment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform MSA with MAFFT\naln_fungi <- align_sequences(busco_seqs_fungi, threads = 4)\n\n# Trim alignment to remove columns with >50% of gaps\naln_fungi_trimmed <- lapply(aln_fungi, trim_alignment, max_gap = 0.5)\n```\n:::\n\n\nNow, let's infer a species tree using IQ-TREE2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutgroup <- \"aphanomyces.astaci,aphanomyces.invadans,globisporangium.ultimum\"\ntrees_fungi <- infer_species_tree(aln_fungi_trimmed, outgroup, threads = 4)\n```\n:::\n\n\nFinally, for comparative reasons, we will also infer a single tree from a\nconcatenated multiple sequence alignment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Concatenate alignments\naln_fungi_conc <- Reduce(xscat, aln_fungi_trimmed)\nnames(aln_fungi_conc) <- names(aln_fungi_trimmed[[1]])\n\n# Infer tree from concatenated alignment\ntree_fungi_conc <- infer_species_tree(\n    list(conc = aln_fungi_conc), \n    outgroup, threads = 4\n)\n```\n:::\n\n\nCombining the trees and saving them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine trees\nfungi_busco_trees <- c(\n    tree_fungi_conc, trees_fungi\n)\n\nsave(\n    fungi_busco_trees, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"trees\", \"fungi_busco_trees.rda\")\n)\n```\n:::\n\n\n#### Ensembl Plants\n\nHere, because no BUSCO gene is present in all species, we will only infer\na single tree from concatenated alignments.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform MSA with MAFFT\naln_plants <- align_sequences(plants_busco_seqs, threads = 4)\n\n# Trim alignment to remove columns with >50% of gaps\naln_plants_trimmed <- lapply(aln_plants, trim_alignment, max_gap = 0.5)\n```\n:::\n\n\nFinally, let's infer a species tree from a concatenated alignment.\nAs outgroups, we're going to use *Chondrus crispus*, *Galdieria sulphuraria*, \nand *Cyanidioschyzon merolae*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutgroup <- \"chondrus.crispus,galdieria.sulphuraria,cyanidioschyzon.merolae\"\n\n# Concatenate alignments\naln_plants_conc <- concatenate_alignments(aln_plants_trimmed)\n\n# Infer tree from concatenated alignment\nplants_busco_trees <- infer_species_tree(\n    list(conc = aln_plants_conc), \n    outgroup, threads = 4\n)\n\n# Save tree\nsave(\n    plants_busco_trees, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"trees\", \"plants_busco_trees.rda\")\n)\n```\n:::\n\n\n#### Ensembl Protists\n\nFor this instance, two BUSCO genes were conserved across all species,\nso we will infer trees for each family + a tree from a concatenated alignment.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform MSA with MAFFT\naln_protists <- align_sequences(protists_busco_seqs, threads = 4)\n\n# Trim alignment to remove columns with >50% of gaps\naln_protists_trimmed <- lapply(aln_protists, trim_alignment, max_gap = 0.5)\n```\n:::\n\n\nNow, let's infer species trees. As outgroup, we will use Fornicata\n(*Giardia lamblia*) based on [this paper](10.1126/sciadv.ade4973).\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutgroup <- \"giardia.lamblia\"\n\n# Path 1: a tree per BUSCO gene\nprotists_trees1 <- infer_species_tree(\n    aln_protists_trimmed, outgroup, threads = 4\n)\n\n# Path 2: a single tree from a concatenated alignment\nprotists_trees2 <- infer_species_tree(\n    list(conc = concatenate_alignments(aln_protists_trimmed)),\n    outgroup, threads = 6\n)\n\n\n# Combine trees and save them\nprotists_busco_trees <- c(protists_trees1, protists_trees2)\n\nsave(\n    protists_busco_trees, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"trees\", \"protists_busco_trees.rda\")\n)\n```\n:::\n\n\nHowever, even though we specified *Giardia lamblia*, IQ-TREE2 placed it\nas an ingroup. This suggests that, based on our data (BUSCO sequences),\n*Giardia lamblia* may not be a good outgroup.\n\nSince protists are not actually a real phylogenetic group (not monophyletic),\ninstead of digging deeper into the real phylogeny of the group and searching\nfor a proper outgroup, we will simply use this phylogeny but acknowledging\nthat it may not be completely accurate.\n\n#### Ensembl Metazoa\n\nFor this instance, two BUSCO genes were conserved across all species,\nso we will infer trees for each family + a tree from a concatenated alignment.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform MSA with MAFFT\naln_metazoa <- align_sequences(metazoa_busco_seqs, threads = 4)\n\n# Trim alignment to remove columns with >50% of gaps\naln_metazoa_trimmed <- lapply(aln_metazoa, trim_alignment, max_gap = 0.5)\n```\n:::\n\n\nNow, let's infer a species tree. As outgroup, we will use the\nctenophore *Mnemiopsis leidyi*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutgroup <- \"mnemiopsis.leidyi\"\n\n# Get a single tree from a concatenated alignment\nmetazoa_busco_trees <- infer_species_tree(\n    list(conc = concatenate_alignments(aln_metazoa_trimmed)),\n    outgroup, threads = 6\n)\n\n# Save tree\nsave(\n    metazoa_busco_trees, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"trees\", \"metazoa_busco_trees.rda\")\n)\n```\n:::\n\n\n#### Ensembl Vertebrates\n\nFor this instance, no BUSCO gene was conserved in all species. Thus, \nwe will infer a single tree from a concatenated alignment of ten \nrepresentative BUSCOs.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform MSA with MAFFT\naln_vertebrates <- align_sequences(vertebrates_busco_seqs, threads = 4)\n\n# Trim alignment to remove columns with >50% of gaps\naln_vertebrates_trimmed <- lapply(aln_vertebrates, trim_alignment, max_gap = 0.5)\n```\n:::\n\n\nNow, let's infer a species tree. As outgroup, we will use the\nyeast *Saccharomyces cerevisiae*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutgroup <- \"saccharomyces.cerevisiae\"\n\n# Get a single tree from a concatenated alignment\nvertebrates_busco_trees <- infer_species_tree(\n    list(conc = concatenate_alignments(aln_vertebrates_trimmed)),\n    outgroup, threads = 6\n)\n\n# Save tree\nsave(\n    vertebrates_busco_trees, compress = \"xz\",\n    file = here(\"products\", \"result_files\", \"trees\", \"vertebrates_busco_trees.rda\")\n)\n```\n:::\n\n\n## Obtaining BUSCO scores\n\nFinally, since we ran BUSCO to obtain single-copy gene families, we will\nalso use BUSCO's output to explore gene space completeness across species\nin Ensembl instances.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read BUSCO completeness stats\n## Ensembl Fungi\nfungi_busco_scores <- read_busco(\n    \"~/Downloads/busco_fungi/ensembl_fungi\"\n)\n\n## Ensembl Plants\nplants_busco_scores <- read_busco(\n    \"~/Downloads/busco_plants/ensemblplants\"\n)\n\n## Ensembl Protists\nprotists_busco_scores <- read_busco(\n    \"~/Downloads/busco_protists/ensemblprotists\"\n)\n\n## Ensembl Metazoa\nmetazoa_busco_scores <- read_busco(\n    \"~/Downloads/busco_metazoa/ensemblmetazoa\"\n)\n\n## Ensembl Vertebrates\nvertebrates_busco_scores <- read_busco(\n    \"~/Downloads/busco_vertebrates/ensemblvertebrates\"\n)\n\n# Save files\nsave(\n    fungi_busco_scores, compress = \"xz\",\n    file = here(\n        \"products\", \"result_files\", \"busco_scores\", \"fungi_busco_scores.rda\"\n    )\n)\n\nsave(\n    plants_busco_scores, compress = \"xz\",\n    file = here(\n        \"products\", \"result_files\", \"busco_scores\", \"plants_busco_scores.rda\"\n    )\n)\n\nsave(\n    protists_busco_scores, compress = \"xz\",\n    file = here(\n        \"products\", \"result_files\", \"busco_scores\", \"protists_busco_scores.rda\"\n    )\n)\n\nsave(\n    metazoa_busco_scores, compress = \"xz\",\n    file = here(\n        \"products\", \"result_files\", \"busco_scores\", \"metazoa_busco_scores.rda\"\n    )\n)\n\nsave(\n    vertebrates_busco_scores, compress = \"xz\",\n    file = here(\n        \"products\", \"result_files\", \"busco_scores\", \"vertebrates_busco_scores.rda\"\n    )\n)\n```\n:::\n\n\n## Session info {.unnumbered}\n\nThis document was created under the following conditions:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2024-02-12\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package          * version   date (UTC) lib source\n AnnotationDbi      1.64.1    2023-11-03 [1] Bioconductor\n ape                5.7-1     2023-03-13 [1] CRAN (R 4.3.2)\n aplot              0.2.2     2023-10-06 [1] CRAN (R 4.3.2)\n beeswarm           0.4.0     2021-06-01 [1] CRAN (R 4.3.2)\n Biobase            2.62.0    2023-10-24 [1] Bioconductor\n BiocFileCache      2.10.1    2023-10-26 [1] Bioconductor\n BiocGenerics     * 0.48.1    2023-11-01 [1] Bioconductor\n biomaRt          * 2.58.0    2023-10-24 [1] Bioconductor\n Biostrings       * 2.70.1    2023-10-25 [1] Bioconductor\n bit                4.0.5     2022-11-15 [1] CRAN (R 4.3.2)\n bit64              4.0.5     2020-08-30 [1] CRAN (R 4.3.2)\n bitops             1.0-7     2021-04-24 [1] CRAN (R 4.3.2)\n blob               1.2.4     2023-03-17 [1] CRAN (R 4.3.2)\n bold               1.3.0     2023-05-02 [1] CRAN (R 4.3.2)\n cachem             1.0.8     2023-05-01 [1] CRAN (R 4.3.2)\n cli                3.6.2     2023-12-11 [1] CRAN (R 4.3.2)\n codetools          0.2-19    2023-02-01 [4] CRAN (R 4.2.2)\n cogeqc           * 1.6.0     2023-10-24 [1] Bioconductor\n colorspace         2.1-0     2023-01-23 [1] CRAN (R 4.3.2)\n conditionz         0.1.0     2019-04-24 [1] CRAN (R 4.3.2)\n crayon             1.5.2     2022-09-29 [1] CRAN (R 4.3.2)\n crul               1.4.0     2023-05-17 [1] CRAN (R 4.3.2)\n curl               5.2.0     2023-12-08 [1] CRAN (R 4.3.2)\n data.table         1.14.10   2023-12-08 [1] CRAN (R 4.3.2)\n DBI                1.1.3     2022-06-18 [1] CRAN (R 4.3.2)\n dbplyr             2.4.0     2023-10-26 [1] CRAN (R 4.3.2)\n digest             0.6.33    2023-07-07 [1] CRAN (R 4.3.2)\n dplyr            * 1.1.4     2023-11-17 [1] CRAN (R 4.3.2)\n evaluate           0.23      2023-11-01 [1] CRAN (R 4.3.2)\n fansi              1.0.6     2023-12-08 [1] CRAN (R 4.3.2)\n fastmap            1.1.1     2023-02-24 [1] CRAN (R 4.3.2)\n filelock           1.0.3     2023-12-11 [1] CRAN (R 4.3.2)\n forcats          * 1.0.0     2023-01-29 [1] CRAN (R 4.3.2)\n foreach            1.5.2     2022-02-02 [1] CRAN (R 4.3.2)\n fs                 1.6.3     2023-07-20 [1] CRAN (R 4.3.2)\n generics           0.1.3     2022-07-05 [1] CRAN (R 4.3.2)\n GenomeInfoDb     * 1.38.2    2023-12-13 [1] Bioconductor 3.18 (R 4.3.2)\n GenomeInfoDbData   1.2.11    2023-12-21 [1] Bioconductor\n ggbeeswarm         0.7.2     2023-04-29 [1] CRAN (R 4.3.2)\n ggfun              0.1.3     2023-09-15 [1] CRAN (R 4.3.2)\n ggplot2          * 3.4.4     2023-10-12 [1] CRAN (R 4.3.2)\n ggplotify          0.1.2     2023-08-09 [1] CRAN (R 4.3.2)\n ggtree             3.10.0    2023-10-24 [1] Bioconductor\n glue               1.6.2     2022-02-24 [1] CRAN (R 4.3.2)\n gridGraphics       0.5-1     2020-12-13 [1] CRAN (R 4.3.2)\n gtable             0.3.4     2023-08-21 [1] CRAN (R 4.3.2)\n here             * 1.0.1     2020-12-13 [1] CRAN (R 4.3.2)\n Herper           * 1.10.1    2024-02-08 [1] Github (RockefellerUniversity/Herper@ae37f3d)\n hms                1.1.3     2023-03-21 [1] CRAN (R 4.3.2)\n htmltools          0.5.7     2023-11-03 [1] CRAN (R 4.3.2)\n htmlwidgets        1.6.4     2023-12-06 [1] CRAN (R 4.3.2)\n httpcode           0.3.0     2020-04-10 [1] CRAN (R 4.3.2)\n httr               1.4.7     2023-08-15 [1] CRAN (R 4.3.2)\n igraph             2.0.1.1   2024-01-30 [1] CRAN (R 4.3.2)\n IRanges          * 2.36.0    2023-10-24 [1] Bioconductor\n iterators          1.0.14    2022-02-05 [1] CRAN (R 4.3.2)\n jsonlite           1.8.8     2023-12-04 [1] CRAN (R 4.3.2)\n KEGGREST           1.42.0    2023-10-24 [1] Bioconductor\n knitr              1.45      2023-10-30 [1] CRAN (R 4.3.2)\n lattice            0.22-5    2023-10-24 [4] CRAN (R 4.3.1)\n lazyeval           0.2.2     2019-03-15 [1] CRAN (R 4.3.2)\n lifecycle          1.0.4     2023-11-07 [1] CRAN (R 4.3.2)\n lubridate        * 1.9.3     2023-09-27 [1] CRAN (R 4.3.2)\n magrittr           2.0.3     2022-03-30 [1] CRAN (R 4.3.2)\n Matrix             1.6-3     2023-11-14 [4] CRAN (R 4.3.2)\n memoise            2.0.1     2021-11-26 [1] CRAN (R 4.3.2)\n munsell            0.5.0     2018-06-12 [1] CRAN (R 4.3.2)\n nlme               3.1-163   2023-08-09 [4] CRAN (R 4.3.1)\n patchwork          1.2.0     2024-01-08 [1] CRAN (R 4.3.2)\n pillar             1.9.0     2023-03-22 [1] CRAN (R 4.3.2)\n pkgconfig          2.0.3     2019-09-22 [1] CRAN (R 4.3.2)\n plyr               1.8.9     2023-10-02 [1] CRAN (R 4.3.2)\n png                0.1-8     2022-11-29 [1] CRAN (R 4.3.2)\n prettyunits        1.2.0     2023-09-24 [1] CRAN (R 4.3.2)\n progress           1.2.3     2023-12-06 [1] CRAN (R 4.3.2)\n purrr            * 1.0.2     2023-08-10 [1] CRAN (R 4.3.2)\n R6                 2.5.1     2021-08-19 [1] CRAN (R 4.3.2)\n rappdirs           0.3.3     2021-01-31 [1] CRAN (R 4.3.2)\n Rcpp               1.0.11    2023-07-06 [1] CRAN (R 4.3.2)\n RCurl              1.98-1.13 2023-11-02 [1] CRAN (R 4.3.2)\n readr            * 2.1.4     2023-02-10 [1] CRAN (R 4.3.2)\n reshape2           1.4.4     2020-04-09 [1] CRAN (R 4.3.2)\n reticulate       * 1.35.0    2024-01-31 [1] CRAN (R 4.3.2)\n rjson              0.2.21    2022-01-09 [1] CRAN (R 4.3.2)\n rlang              1.1.2     2023-11-04 [1] CRAN (R 4.3.2)\n rmarkdown          2.25      2023-09-18 [1] CRAN (R 4.3.2)\n rprojroot          2.0.4     2023-11-05 [1] CRAN (R 4.3.2)\n RSQLite            2.3.4     2023-12-08 [1] CRAN (R 4.3.2)\n rstudioapi         0.15.0    2023-07-07 [1] CRAN (R 4.3.2)\n S4Vectors        * 0.40.2    2023-11-23 [1] Bioconductor 3.18 (R 4.3.2)\n scales             1.3.0     2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo        1.2.2     2021-12-06 [1] CRAN (R 4.3.2)\n stringi            1.8.3     2023-12-11 [1] CRAN (R 4.3.2)\n stringr          * 1.5.1     2023-11-14 [1] CRAN (R 4.3.2)\n taxize           * 0.9.100   2022-04-22 [1] CRAN (R 4.3.2)\n tibble           * 3.2.1     2023-03-20 [1] CRAN (R 4.3.2)\n tidyr            * 1.3.0     2023-01-24 [1] CRAN (R 4.3.2)\n tidyselect         1.2.0     2022-10-10 [1] CRAN (R 4.3.2)\n tidytree           0.4.6     2023-12-12 [1] CRAN (R 4.3.2)\n tidyverse        * 2.0.0     2023-02-22 [1] CRAN (R 4.3.2)\n timechange         0.2.0     2023-01-11 [1] CRAN (R 4.3.2)\n treeio             1.26.0    2023-10-24 [1] Bioconductor\n tzdb               0.4.0     2023-05-12 [1] CRAN (R 4.3.2)\n utf8               1.2.4     2023-10-22 [1] CRAN (R 4.3.2)\n uuid               1.1-1     2023-08-17 [1] CRAN (R 4.3.2)\n vctrs              0.6.5     2023-12-01 [1] CRAN (R 4.3.2)\n vipor              0.4.7     2023-12-18 [1] CRAN (R 4.3.2)\n withr              2.5.2     2023-10-30 [1] CRAN (R 4.3.2)\n xfun               0.41      2023-11-01 [1] CRAN (R 4.3.2)\n XML                3.99-0.16 2023-11-29 [1] CRAN (R 4.3.2)\n xml2               1.3.6     2023-12-04 [1] CRAN (R 4.3.2)\n XVector          * 0.42.0    2023-10-24 [1] Bioconductor\n yaml               2.3.8     2023-12-11 [1] CRAN (R 4.3.2)\n yulab.utils        0.1.2     2023-12-22 [1] CRAN (R 4.3.2)\n zlibbioc           1.48.0    2023-10-24 [1] Bioconductor\n zoo                1.8-12    2023-04-13 [1] CRAN (R 4.3.2)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}